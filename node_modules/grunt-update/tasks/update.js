// Generated by CoffeeScript 1.6.3
var fs,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

module.exports = function(grunt) {
  var UndefinedTaskError, description, filesAreOutdated, getMultiTaskFiles, getTaskFiles, isMultiTask, isValidMultiTaskTarget, path, statSyncOrNull, taskIsOutdated, _;
  _ = grunt.util._;
  path = require('path');
  description = grunt.file.readJSON(path.join(path.dirname(module.filename), '../package.json')).description;
  UndefinedTaskError = (function(_super) {
    __extends(UndefinedTaskError, _super);

    function UndefinedTaskError(task) {
      this.task = task;
    }

    return UndefinedTaskError;

  })(Error);
  statSyncOrNull = function(path) {
    var error;
    try {
      return fs.statSync(path);
    } catch (_error) {
      error = _error;
      if (!(error.errno === 34 && error.code === 'ENOENT')) {
        throw error;
      }
      return null;
    }
  };
  filesAreOutdated = function(srcFiles, destFiles) {
    var newestSrcTime;
    newestSrcTime = Math.max.apply(Math, (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = srcFiles.length; _i < _len; _i++) {
        path = srcFiles[_i];
        _results.push(((_ref = statSyncOrNull(path)) != null ? _ref.mtime : void 0) || -Infinity);
      }
      return _results;
    })());
    return destFiles.some(function(path) {
      var _ref;
      return (((_ref = statSyncOrNull(path)) != null ? _ref.mtime : void 0) || -Infinity) < newestSrcTime;
    });
  };
  isValidMultiTaskTarget = function(target) {
    return !/^_|^options$/.test(target);
  };
  isMultiTask = function(task) {
    var taskObject;
    taskObject = grunt.task._tasks[task];
    return Boolean(taskObject != null ? taskObject.multi : void 0);
  };
  getTaskFiles = function(task, target) {
    var config;
    if (isMultiTask(task)) {
      return getMultiTaskFiles(task, target);
    }
    config = grunt.config.getRaw(task);
    if (!config) {
      throw new UndefinedTaskError(task);
    }
    return grunt.task.normalizeMultiTaskFiles(config);
  };
  getMultiTaskFiles = function(task, target) {
    var targets;
    if (target === '*') {
      target = null;
    }
    targets = target ? [target] : Object.keys(grunt.config.getRaw(task || {})).filter(isValidMultiTaskTarget);
    return _.flatten(targets.map(function(target) {
      var config;
      config = grunt.config.getRaw(_.compact([task, target]));
      if (!config) {
        throw new UndefinedTaskError(_.compact([task, target]).join(':'));
      }
      return grunt.task.normalizeMultiTaskFiles(config);
    }));
  };
  taskIsOutdated = function(task) {
    var files, target, _ref;
    _ref = task.split(/:/).slice(0, 2), task = _ref[0], target = _ref[1];
    files = getTaskFiles(task, target);
    return files.some(function(_arg) {
      var dest, src;
      src = _arg.src, dest = _arg.dest;
      return filesAreOutdated(src, [dest]);
    });
  };
  return grunt.registerMultiTask('update', description, function() {
    var e, outdatedTasks, tasks;
    try {
      tasks = this.data.tasks;
      if (grunt.util.kindOf(this.data) === 'array') {
        if (tasks == null) {
          tasks = this.data;
        }
      }
      if (tasks == null) {
        tasks = grunt.config.get('update.tasks');
      }
      if (!tasks) {
        this.requiresConfig('tasks');
      }
      outdatedTasks = tasks.filter(taskIsOutdated);
      grunt.task.run(outdatedTasks);
      return true;
    } catch (_error) {
      e = _error;
      if (!(e instanceof UndefinedTaskError)) {
        throw e;
      }
      grunt.fail.warn("Task \"" + e.task + "\" not found.");
      return false;
    }
  });
};

/*
//@ sourceMappingURL=update.map
*/
